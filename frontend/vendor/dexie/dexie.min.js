/* Minimal Dexie-compatible wrapper for ADA offline use.
 * NOTE: This is a lightweight shim that supports the subset of Dexie APIs used in ADA.
 */
(function (global) {
    'use strict';

    function parsePrimaryKey(schema) {
        const parts = schema.split(',').map(function (part) { return part.trim(); }).filter(Boolean);
        const primary = parts[0] || 'id';
        const autoIncrement = primary.startsWith('++');
        const keyPath = primary.replace('++', '').replace('&', '');
        return { keyPath: keyPath, autoIncrement: autoIncrement };
    }

    function Dexie(name) {
        this.name = name;
        this._version = 1;
        this._schema = {};
        this._db = null;
        this._openPromise = null;
        this._tables = {};
    }

    Dexie.prototype.version = function (version) {
        this._version = version;
        const self = this;
        return {
            stores: function (schema) {
                self._schema = schema || {};
                Object.keys(self._schema).forEach(function (tableName) {
                    if (!self._tables[tableName]) {
                        self._tables[tableName] = new Table(self, tableName);
                        self[tableName] = self._tables[tableName];
                    }
                });
                return self;
            }
        };
    };

    Dexie.prototype.open = function () {
        const self = this;
        if (self._openPromise) return self._openPromise;
        self._openPromise = new Promise(function (resolve, reject) {
            const request = indexedDB.open(self.name, self._version);
            request.onupgradeneeded = function (event) {
                const db = event.target.result;
                Object.keys(self._schema).forEach(function (tableName) {
                    if (db.objectStoreNames.contains(tableName)) return;
                    const schema = self._schema[tableName] || 'id';
                    const primary = parsePrimaryKey(schema);
                    db.createObjectStore(tableName, {
                        keyPath: primary.keyPath,
                        autoIncrement: primary.autoIncrement
                    });
                });
            };
            request.onsuccess = function () {
                self._db = request.result;
                resolve(self);
            };
            request.onerror = function () {
                reject(request.error);
            };
        });
        return self._openPromise;
    };

    function Table(db, name) {
        this.db = db;
        this.name = name;
    }

    Table.prototype._withStore = function (mode, fn) {
        const self = this;
        return self.db.open().then(function () {
            return new Promise(function (resolve, reject) {
                const tx = self.db._db.transaction(self.name, mode);
                const store = tx.objectStore(self.name);
                fn(store, resolve, reject);
                tx.onabort = function () {
                    reject(tx.error || new Error('Transaction aborted'));
                };
                tx.onerror = function () {
                    reject(tx.error || new Error('Transaction error'));
                };
            });
        });
    };

    Table.prototype.get = function (key) {
        return this._withStore('readonly', function (store, resolve, reject) {
            const request = store.get(key);
            request.onsuccess = function () { resolve(request.result); };
            request.onerror = function () { reject(request.error); };
        });
    };

    Table.prototype.toArray = function () {
        return this._withStore('readonly', function (store, resolve, reject) {
            const request = store.getAll();
            request.onsuccess = function () { resolve(request.result || []); };
            request.onerror = function () { reject(request.error); };
        });
    };

    Table.prototype.put = function (value) {
        return this._withStore('readwrite', function (store, resolve, reject) {
            const request = store.put(value);
            request.onsuccess = function () { resolve(request.result); };
            request.onerror = function () { reject(request.error); };
        });
    };

    Table.prototype.add = function (value) {
        return this._withStore('readwrite', function (store, resolve, reject) {
            const request = store.add(value);
            request.onsuccess = function () { resolve(request.result); };
            request.onerror = function () { reject(request.error); };
        });
    };

    Table.prototype.delete = function (key) {
        return this._withStore('readwrite', function (store, resolve, reject) {
            const request = store.delete(key);
            request.onsuccess = function () { resolve(); };
            request.onerror = function () { reject(request.error); };
        });
    };

    Table.prototype.bulkPut = function (items) {
        const list = Array.isArray(items) ? items : [];
        return this._withStore('readwrite', function (store, resolve, reject) {
            let index = 0;
            function next() {
                if (index >= list.length) {
                    resolve();
                    return;
                }
                const request = store.put(list[index++]);
                request.onsuccess = next;
                request.onerror = function () { reject(request.error); };
            }
            next();
        });
    };

    global.Dexie = Dexie;
})(window);
